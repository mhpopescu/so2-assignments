mount -t pitix /tmp/pitix.loop /tmp/pitix.mnt/ -o loop

Rationamentul de la minix pentru superblock
pag 538 Operating Systems Design and Implementation, Third Edition
By Andrew S. Tanenbaum
The information in the superblock is redundant because sometimes it is needed in one form and
sometimes in another. With 1 KB devoted to the superblock, it makes sense to compute this
information in all the forms it is needed, rather than having to recompute it frequently during
execution. The zone number of the first data zone on the disk, for example, can be calculated
from the block size, zone size, number of i-nodes, and number of zones, but it is faster just to
keep it in the superblock. The rest of the superblock is wasted anyhow, so using up another word
of it costs nothing.

In felul acesta lucram doar cu structura sbi


DAR
static inline struct pitix_super_block *pitix_sb(struct super_block *sb)
{
	return sb->s_fs_info;
}

DECI se vrea folosirea structurii pitix_super_block fara sa mai avem pitix_sb_info. Respectam structura data


DUPA am vazut ca se pot modifica fisierele header
http://cursuri.cs.pub.ro/pipermail/so2/2018-April/007622.html





pentru directoare: lookup, unlink, mkdir, rmdir, iterate
pentru fișiere: create, truncate, funcția de bitmap

pitix_new_inode nu e ok sa setez dupa ce il fac dirty
	// FIXME 	MOVE HERE because of make inode_dirty
	// inode_init_owner(inode, dir, mode);
+ ca nu pot verifica erorile *error = -ENOSPC;

In loc sa tin in private info am urmat exemplul din pitix
static inline struct pitix_inode_info *pitix_i(struct inode *inode)
{
	return container_of(inode, struct pitix_inode_info, vfs_inode);
}

desi poate era o idee am considerat ca pentru un simplu nivel de indirectare nu e nevoie sa ma complic cu arborele din minix. nu construiesc adancimea